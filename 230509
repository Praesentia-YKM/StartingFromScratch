● NON-EQUI JOIN(비동등 조인)

: 조인 조건이 특정 범위 내에 있는지를 조사하기 위해서 WHERE 절에 조인 조건을 = 연산자 이외의 비교 연산자를 사용한다.

예1) 급여 등급을 5개로 나누어 놓은 salgrade에서 정보를 얻어와서 각 사원의 급여 등급을 조회하기

SQL>select * from salgrade;

GRADE           LOSAL                 HISAL

- -------- ---------- -----------

1                      700                    1200

2                      1201                   1400

3                      1401                   2000

4                      2001                   3000

5                      3001                   9999

SQL>select e.ename, e.sal, s.grade from emp e, salgrade s where e.sal >= s.losal and e.sal <= s.hisal;

- -> emp 테이블의 sal이 salgrade테이블의 losal과 hisal 조건에 맞아떨어지는 grade를 조회할 수 있도록 해준다.

SQL>select e.ename, e.sal, s.grade from emp e, salgrade s where e.sal between s.losal and s.hisal;

- -> 위와 같은 방법으로 between ~ and를 이용해서 조회할 수 있다.
## CASE WHEN END

---

오라클에서 if 문과 비슷한 기능을 하는 DECODE 함수가 있다. 그러나 DECODE 함수는 조건이 많아지면 가독성이 떨어지고 복잡해지며, 가장 큰 문제는 오라클 SQL에서만 사용할 수 있는 비표준 함수이다.

오라클에서 DECODE 함수를 대체할 수 있는 기능이 CASE 표현식이며 가독성이 좋고 더 많은 기능을 제공한다. 조건이 복잡한 경우 DECODE 함수 보다 CASE 표현식을 사용할 것을 권장한다.

![https://blog.kakaocdn.net/dn/03vYC/btqE5fwA1US/Uf4jRvoPOFKFeEYGBcuZ0k/img.png](https://blog.kakaocdn.net/dn/03vYC/btqE5fwA1US/Uf4jRvoPOFKFeEYGBcuZ0k/img.png)

오라클 CASE 표현식

### **If 문 방식**

```sql
SELECT ename
     , deptno
     , CASE WHEN deptno = '10' THEN 'New York'
            WHEN deptno = '20' THEN 'Dallas'
            ELSE 'Unknown'
       END AS loc_name
  FROM emp
 WHERE job = 'MANAGER'
```

CASE 표현식에서 **ELSE 부분은 생략**이 가능하며, 만족하는 조건이 없으면 **NULL**을 리턴한다. CASE 표현식은 SELECT 절, WHERE 절, PL/SQL 등 많은 부분에서 사용이 가능하다.

### **Switch 문 방식**

```sql
SELECT ename
     , deptno
     , CASE deptno
            WHEN 10 THEN 'New York'
            WHEN 20 THEN 'Dallas'
            ELSE 'Unknown'
       END AS loc_name
  FROM scott.emp
 WHERE job = 'MANAGER'
```

CASE 표현식은 C, JAVA의 Swith문과 비슷한 방식으로 사용이 가능하다. CASE 뒤에 비교할 컬럼을 입력하고 WHEN 뒤에 값을 입력해 놓으면 된다. 단순 값만 비교할 때는 조금 더 쿼리문을 단순하게 표현할 수 있다.

## DECODE

---

예) **DECODE(컬럼, 조건1, 결과1, 조건2, 결과2, 조건3, 결과3..........)**

[https://t1.daumcdn.net/cfile/tistory/99D8F6415CFFC30731](https://t1.daumcdn.net/cfile/tistory/99D8F6415CFFC30731)

```sql
WITH temp AS (
    SELECT 'M' gender FROM dual UNION ALL
    SELECT 'F' gender FROM dual UNION ALL
    SELECT 'X' gender FROM dual
)

SELECT gender
     , DECODE(gender, 'M', '남자', 'F', '여자', '기타') gender2
  FROM temp
```

if (gender == "M") {    return "남자";} else if (gender == "F") {    return "여자";} else {    return "기타";}


-- --------------------------------------------------------------------------------------------------------------------------------
-- 5월 8일 202322191 양권모

/* 8장 연습문제 - 조인*/
-- EMP테이블 조회
SELECT * FROM EMP;

-- DEPT 테이블 조회
SELECT * FROM DEPT;

-- 2개의 테이블 조회
SELECT *
FROM EMP,DEPT
ORDER BY EMPNO;

-- EMP테이블과 DEPT테이블의 DEPTNO 컬럼이 일치하는 데이터만 출력
SELECT *
FROM EMP,DEPT 
WHERE EMP.DEPTNO=DEPT.DEPTNO
ORDER BY EMPNO;

-- 테이블 별칭 설정
SELECT *
FROM EMP E,DEPT D 
WHERE E.DEPTNO=D.DEPTNO
ORDER BY EMPNO;

-- 1분복습
SELECT E.EMPNO, D.DNAME 
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO 
ORDER BY EMPNO;


SELECT E.EMPNO, E.ENAME, D.DEPTNO,D.DNAME,D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO AND SAL>=3000;

-- 1분복습 ( DNAME : 부서명)
SELECT E.EMPNO, D.DNAME,E.SAL,D.DEPTNO,D.DNAME,D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND SAL<=2500
AND EMPNO<=9999
ORDER BY E.EMPNO;

-- 비등가 조인
SELECT *
FROM SALGRADE;

-- 급여 범위를 지정하는 조건식을 조인하기(SALGRADE가 급여등급으로 급여를 표현했기 때문)
SELECT *
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

-- 자체조인 => SELF JOIN : 하나의 테이블을 여러개의 별칭을 줘서 사용하는 것
SELECT E1.ENAME,E1.ENAME,E1.MGR,
		E2.EMPNO AS MGR_EMPNO,
		E2.ENAME AS MGR_ENAME
FROM EMP E1 , EMP E2
WHERE E1.MGR=E2.EMPNO;

-- 왼쪽 외부 조인(상급자가 존재하지 않는 사원도 출력)
SELECT E1.ENAME,E1.ENAME,E1.MGR,
		E2.EMPNO AS MGR_EMPNO,
		E2.ENAME AS MGR_ENAME
FROM EMP E1 , EMP E2
WHERE E1.MGR=E2.EMPNO(+)
ORDER BY E1.EMPNO;

-- 오른쪽 외부 조인(상급자가 존재하지 않는 사원도 출력)
SELECT E1.ENAME,E1.ENAME,E1.MGR,
		E2.EMPNO AS MGR_EMPNO,
		E2.ENAME AS MGR_ENAME
FROM EMP E1 , EMP E2
WHERE E1.MGR(+)=E2.EMPNO
ORDER BY E1.EMPNO;

-- SQL-99표준 문법으로 배우는 조인
SELECT E.EMPNO,E.ENAME,E.JOB,E.MGR,E.HIREDATE,E.SAL,E.COMM,DEPTNO,D.DNAME,D.LOC
FROM EMP E NATURAL JOIN DEPT D 
ORDER BY DEPTNO,E.EMPNO;

-- 하위 문법과 같음
SELECT E.EMPNO,E.ENAME,E.JOB,E.MGR,E.HIREDATE,E.SAL,E.COMM,DEPTNO,D.DNAME,D.LOC
FROM EMP E 
JOIN DEPT D ON E.DEPTNO=D.DEPTNO
ORDER BY DEPTNO,E.EMPNO;

-- JOIN ~ USING
SELECT E.EMPNO,E.ENAME,E.JOB,E.MGR,E.HIREDATE,E.SAL,E.COMM,
		DEPTNO,D.DNAME,D.LOC 
FROM EMP E JOIN DEPT D USING(DEPTNO)
WHERE SAL>=3000
ORDER BY DEPTNO,E.EMPNO;

-- JOIN ~ ON
SELECT E.EMPNO,E.ENAME,E.JOB,E.MGR,E.HIREDATE,E.SAL,E.COMM,
		E.DEPTNO,D.DNAME,D.LOC 
FROM EMP E JOIN DEPT D ON E.DEPTNO=D.DEPTNO 
WHERE SAL>=3000
ORDER BY DEPTNO,E.EMPNO;

-- 왼쪽 외부조인
SELECT E1.EMPNO,E1.ENAME,E1.MGR
	  ,E2.EMPNO AS MGR_EMPNO
	  ,E2.ENAME AS MGR_ENAME
FROM EMP E1 
LEFT OUTER JOIN EMP E2 ON (E1.MGR=E2.EMPNO)
ORDER BY E1.EMPNO;

-- 오른쪽 외부조인
SELECT E1.EMPNO,E1.ENAME,E1.MGR
	  ,E2.EMPNO AS MGR_EMPNO
	  ,E2.ENAME AS MGR_ENAME
FROM EMP E1 
RIGHT OUTER JOIN EMP E2 ON (E1.MGR=E2.EMPNO)
ORDER BY E1.EMPNO,MGR_EMPNO;

-- 전체 외부조인을 SQL-99로 작성 (기존 : UNION)
SELECT E1.EMPNO,E1.ENAME,E1.MGR
	  ,E2.EMPNO AS MGR_EMPNO
	  ,E2.ENAME AS MGR_ENAME
FROM EMP E1 
FULL OUTER JOIN EMP E2 ON (E1.MGR=E2.EMPNO)
ORDER BY E1.EMPNO,MGR_EMPNO;

-- 1분 복습 SQL-99 표준 문법으로 배우는 조인
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL,
E.COMM, DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D USING (DEPTNO)
WHERE SAL >= 3000
AND E.MGR IS NOT NULL
ORDER BY DEPTNO, E.EMPNO;

-- 퀴즈 1
SELECT E.DEPTNO,D.DNAME,E.EMPNO,E.ENAME,E.SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO=D.DEPTNO
AND SAL>2000
ORDER BY DEPTNO;

SELECT E.DEPTNO,D.DNAME,E.EMPNO,E.ENAME,E.SAL
FROM EMP E
JOIN DEPT D  
ON E.DEPTNO=D.DEPTNO  
WHERE SAL>2000
ORDER BY DEPTNO;

-- 퀴즈 2
SELECT E.DEPTNO
	   ,D.DNAME
	   ,FLOOR(AVG(SAL)) AS AVG_SAL
	   ,FLOOR(MAX(SAL)) AS MAX_SAL
	   ,FLOOR(MIN(SAL)) AS MIN_SAL
	   ,COUNT(*) AS CNT
FROM EMP E,DEPT D
WHERE E.DEPTNO=D.DEPTNO
GROUP BY E.DEPTNO,D.DNAME ;

SELECT E.DEPTNO
	   ,D.DNAME
	   ,FLOOR(AVG(SAL)) AS AVG_SAL
	   ,FLOOR(MAX(SAL)) AS MAX_SAL
	   ,FLOOR(MIN(SAL)) AS MIN_SAL
	   ,COUNT(*) AS CNT
FROM EMP E
JOIN DEPT D
ON E.DEPTNO=D.DEPTNO
GROUP BY E.DEPTNO,D.DNAME ;

-- 퀴즈3
SELECT D.DEPTNO,D.DNAME ,E.EMPNO ,E.ENAME ,E.JOB,E.SAL 
FROM DEPT D,EMP E
WHERE D.DEPTNO=E.DEPTNO 
ORDER BY D.DEPTNO,E.ENAME;

SELECT D.DEPTNO,D.DNAME ,E.EMPNO ,E.ENAME ,E.JOB,E.SAL 
FROM DEPT D
LEFT JOIN EMP E
ON D.DEPTNO=E.DEPTNO 
ORDER BY D.DEPTNO,E.ENAME;

-- 퀴즈 4 ##
SELECT D.DEPTNO
	  ,D.DNAME
	  ,E1.EMPNO
	  ,E1.ENAME 
	  ,E1.MGR 
	  ,E1.SAL
	  ,D.DEPTNO AS DEPTNO_1
	  ,S.LOSAL
	  ,S.HISAL
	  ,S.GRADE
	  ,E2.EMPNO AS MGR_EMPNO
	  ,E2.ENAME AS MGR_ENAME
FROM EMP E1,EMP E2,DEPT D,SALGRADE S
WHERE E1.MGR=E2.EMPNO(+)
AND E1.DEPTNO=D.DEPTNO
AND E1.SAL BETWEEN S.LOSAL AND S.HISAL
ORDER BY D.DEPTNO,E1.EMPNO;

SELECT D.DEPTNO
	  ,D.DNAME
	  ,E1.EMPNO
	  ,E1.ENAME 
	  ,E1.MGR 
	  ,E1.SAL
	  ,D.DEPTNO AS DEPTNO_1
	  ,S.LOSAL
	  ,S.HISAL
	  ,S.GRADE
	  ,E2.EMPNO AS MGR_EMPNO
	  ,E2.ENAME AS MGR_ENAME
FROM EMP E1
LEFT OUTER JOIN EMP E2 
ON E1.MGR=E2.EMPNO
JOIN DEPT D 
ON E1.DEPTNO=D.DEPTNO
JOIN SALGRADE S
ON E1.SAL BETWEEN S.LOSAL AND S.HISAL
ORDER BY D.DEPTNO,E1.EMPNO;

-- -------------------------7장 -------------------------
--소수점을 제외하고 각 부서번호별로 출력

SELECT  DEPTNO
		,FLOOR(AVG(SAL)) AS AVG_SAL
		,FLOOR(MAX(SAL)) AS MAX_SAL
		,FLOOR(MIN(SAL)) AS MIN_SAL
		,COUNT(*) AS CNT
FROM EMP E
GROUP BY DEPTNO;

--퀴즈2 --같은 직책에 종사하는 사원이 3명 이상인 직책과 인원 수를 출력

SELECT JOB ,COUNT(*)
FROM EMP
GROUP BY JOB
HAVING COUNT(*) >= 3;

--퀴즈 3 -- 사월들의 입사연도를 기준으로 부서별로 몇 명이 입사했는지 출력

SELECT TO_CHAR(HIREDATE, 'YYYY') AS HIRE_Y
		,DEPTNO
		,COUNT(*)
FROM EMP
GROUP BY TO_CHAR(HIREDATE, 'YYYY'), DEPTNO;

--퀴즈4 -- 추가수당을 받는 사원수와 받지 않는 수를 출력

SELECT CASE WHEN COMM IS NOT NULL THEN 'O' ELSE 'X' END AS RE_COMM
		, COUNT(*) AS CNT
FROM EMP E
GROUP BY (CASE WHEN COMM IS NOT NULL THEN 'O' ELSE 'X' END);

SELECT DECODE(COMM, NULL, 'X', 'O') AS RE_COMM
		, COUNT(*) AS CNT
FROM EMP E
GROUP BY DECODE(COMM, NULL, 'X', 'O');

--퀴즈5 -- 각 부서의 입사 연도별 사원수, 최고 급여, 급여합, 평균 급여를 출력하고 각 부서별 소계와 총계 출력

SELECT DEPTNO
		, TO_CHAR(HIREDATE, 'YYYY') AS HIRE_YEAR
		, COUNT(1)
		, MAX(SAL) AS MAX_SAL
		, SUM(SAL) AS SUM_SAL
		, AVG(SAL) AS AVG_SAL
FROM EMP E
GROUP BY ROLLUP(DEPTNO, TO_CHAR(HIREDATE, 'YYYY'))
ORDER BY DEPTNO
