자바스크립트 익명 함수는 함수명 대신 변수명에 함수 코드를 저장하는 구현 방식이다. 익명 함수의 소스 코드는 변수값이므로 끝에 세미콜론 ; 을 대입한다. 익명 함수는 호출 시 변수명을 함수명처럼 사용하면 된다.

## 구조

```
  var 변수명 = function( 매개변수 )
  {
    실행문;
  };
```

이 경우 변수값을 변수에 넣은 형태이므로 함수 코드 끝에 세미콜론을 붙여준다.

hello라는 변수명에 "Hello World!"라는 문자가 출력되는 함수 코드를 저장했다.hello()로 익명 함수를 호출하면, 소스코드가 실행된다.

```
<script>
  // 익명 함수 선언 및 변수에 대입
  var hello = function( ) {
    document.write("Hello World!");
  };

//익명 함수 변수명으로 호출
hello();
// result : Hello World!
</script>
```

## 익명함수 + 반환문

return 제어문으로 반환이 되는 경우는 익명 함수를 다른 명령어에 대입시키면 된다.함수를 괄호와 함께 변수처럼 원하는 곳에 기입하면 된다.

```
// 익명 함수 선언 및 변수에 대입
var hi = function( ) {
  var string = "Hello World!";
  return string;
};

//익명 함수의 변수를 출력
document.write( hi( ) );
// result : Hello World!
```

익명 함수의 매개 변수와 반환문이 모두 있는 경우에도 정상 함수와 똑같이 작동한다.

```
//익명 함수 선언 및 매개변수 사용
var fusion = function( a, b ) {
  var z = a + b;
  return z;
};

//익명 함수의 변수를 출력 및 인수 입력
document.write( fusion( "Hello", "World!" ) );
// result : HelloWorld!
```

- 자바스크립트에서 [] 는 배열이긴한데 list개념에 더 가깝다. → 데이터 추가시 datalist.push()를 함
    
    > 자바스크립트에서 객체 {} 를 선언한 후 객체이름만 쓰면 그 객체의 value값이 담김
    > 
    
    ex) var reqData = {} ; 해놓고 아래에 sendData.A= reqData ; 라고하면 reqData의 value값이 sendData에 담긴다
    
    ```sql
    View에서 key, value를 가진 json 배열 형식으로 만들어 보내고 싶은데 
    
    단건이 아닌 다건의 여러개 데이터를  보낼때 중괄호와 대괄호에 개념을 정리하게 되었다.
    
    var dataList = [];
     
    for (var i = 1, j= 100; i <= 3; i++,j+= 100) {
        var data = {};
        data.number = i;
        data.priorSeq = j;
        dataList.push(data); // 데이터 푸시
    }
     
    var reqData = {};
    reqData.dataList = dataList;
     
    var sendData = {};
    sendData.reqData = reqData;
     
    console.log(sendData);
    debugger;
    ```
    
    --> 개발자도구를 통해 debugger 전 결과를 확인해보면
    
     reqData : {dataList: Array(3)}
    
     dataList : (3) [{…}, {…}, {…}]
    
     0 : {number: "1", priorSeq: "100"}
    
     1 : {number: "2", priorSeq: "200"}
    
     2 : {number: "3", priorSeq: "300"}
    
    다음과 같이 나오게 되고
    reqData 는 { [ { }, { }, { } ] } 이런 구조가 된다.
    
    ## JQuery each문
    
    ---
    
    $.each() 메서드는 object 와 배열 모두에서 사용할 수 있는 일반적인 반복 함수입니다.
    
    다시 말해, 배열과 length 속성을 갖는 배열과 유사 배열 객체들을 index를 기준으로 반복할 수 있습니다.
    
    첫 번째 매개변수로 배열이나 객체를 받습니다.
    
    그리고 두번째 매개변수로 콜백함수를 받으며 콜백함수의 인자로는 인덱스와 값을 인자로 갖습니다.
    
    **JAVASCRIPT**
    
    ```
    // 객체을 선언
    var arr= [
        {title : '다음', url : 'http://daum.net'},
        {title : '네이버', url : 'http://naver.com'}
    ];
    
    // $.each() 메서드의 첫번째 매겨변수로 위에서 선언한 배열은 전달
    $.each(arr, function (index, item) {
        // 두 번째 매개변수로는 콜백함수인데 콜백함수의 매개변수 중
        // 첫 번째 index는 배열의 인덱스 또는 객체의 키를 의미하고
        // 두 번째 매개 변수 item은 해당 인덱스나 키가 가진 값을 의미합니다.
    
        var result = '';
    
        result += index +' : ' + item.title + ', ' + item.url;
    
        console.log(result);
    
        // 0 : 다음, http://daum.net
        // 1 : 네이버, http://naver.com
    
    })
    ```
    
    Copy
    
    위에서 첫 번째 매개변수에 배열을 전달했습니다. 배열을 받게 되면 콜백함수의 index, item 은 배열의 인덱스와 값을 가리키게 됩니다.
    
    다음의 예제는 배열대신 객체를 전달하는 경우입니다.
    
    **JAVASCRIPT**
    
    `// 객체를 선언
    var obj = {
        daum: 'http://daum.net',
        naver: 'http://naver.com'
    };
    
    // $.each() 메서드의 첫번째 매겨변수로 위에서 선언한 객체를 전달
    $.each(obj, function (index, item) {
    
        // 객체를 전달받으면 index는 객체의 key(property)를 가리키고
        // item은 키의 값을 가져옵니다.
    
        var result = '';
    
        result += index + ' : ' + item;
    
        console.log(result);
    
        // daum : http://daum.net
        // naver : http://naver.com`
        
        
        # **콜백 함수가 무엇인가요?**

자바스크립트에서는 함수는 객체입니다. 함수의 파라미터로서 객체를 전달할 수 있을까요? 네, 할 수 있습니다.

그래서 우리는 함수의 파라미터로서 다른 함수에 전달하고 감싼 함수의 내부에서 그 함수를 호출합니다. 헷갈리신다고요? 아래에 예시를 보여드리겠습니다.

```
function print(callback) {
    callback();
}

```

print() 함수는 다른 함수를 파라미터로 받아서 내부에서 그것을 호출하고 있습니다. 자바스크립트에서는 가능합니다. 그리고 이걸 우리는 “콜백”이라고 하기로 했어요. 다른 함수의 파라미터로써 전달되는 함수를 콜백 함수라고 합니다. 그러나 그게 다는 아니에요.

아래 비디오에서 콜백 함수의 종류를 시청하실 수 있습니다.

### **콜백 함수가 왜 필요한가요?**

자바스크립트는 코드를 위에서 아래로 순차적으로 실행합니다. 그러나, 코드가 다른 행위가 일어난 뒤에 실행되는 경우도 있고 순차적으로 실행되지 않을 때도 있습니다. 이런 걸 비동기 프로그래밍이라고 합니다.

콜백은 태스크가 끝나기 전에 함수가 실행되지 않는 것을 보장합니다. 다르게 말하자면 콜백은 그 태스크가 끝난 직후에 실행될 것입니다. 콜백은 비동기 자바스크립트 코드를 작성할 수 있도록 해주고 여러 문제와 에러들로부터 안전하게 지켜줍니다.

자바스크립트에서 콜백 함수를 만드는 방법은 어떤 함수의 파라미터로써 함수를 넘기고 어떤 행위나 태스크가 완료된 직후에 콜백 함수를 호출하는 것입니다.

# **콜백을 만드는 방법**

위에 설명한 내용들을 이해하기 위해, 간단한 예제로 시작해 보겠습니다. 콘솔에 로그를 찍어보려고 하는데, 이것은 꼭 3초 뒤에 출력되어야 합니다.

```
const message = function() {
    console.log("This message is shown after 3 seconds");
}

setTimeout(message, 3000);

```

setTimeout 함수는 자바스크립트에 내장된 함수입니다. 이 함수는 주어진 시간(밀리세컨드 단위) 이후에 함수를 호출하거나 표현식을 평가합니다. 그래서 여기 message 함수는 3초가 지난 후에 호출됩니다. (1초 = 1000 밀리세컨드)

다르게 이야기하자면, message 함수는 어떤 일이 일어나기 전이 아니라 뒤에(여기서는 3초가 지난 후에) 호출됩니다. 그래서 이 message 함수는 콜백 함수의 예시라고 할 수 있죠.

### **비동기 함수가 무엇인가요?**

다르게는 비동기 함수를 다른 함수에 호출하는 방법 말고 함수 내부에 직접적으로 정의하는 방법도 있습니다. 이런 방법은 아래와 같습니다.

```
setTimeout(function() {
    console.log("This message is shown after 3 seconds");
}, 3000);

```

보시다시피 여기서 콜백 함수는 이름이 없고 자바스크립트에서 이름이 없는 함수 정의를 "익명 함수"라고 합니다. 이것은 위의 샘플과 정확하게 똑같이 작동합니다.

# **이벤트 처리는요?**

자바스크립트는 이벤트 기반 프로그래밍 언어입니다. 콜백 함수를 이벤트 선언을 위해 사용하기도 합니다. 예를 들어 사용자가 버튼을 클릭하기를 바란다고 해봅시다.

```
<button id="callback-btn">Click here</button>

```

이번에는 사용자가 버튼을 클릭했을 때 콘솔에 메시지를 남겨 보도록 하겠습니다.

```
document.queryselector("#callback-btn")
    .addEventListener("click", function() {
      console.log("User has clicked on the button!");
});

```

첫 번째로 버튼의 id 값을 사용하여 버튼을 선택하고 addEventListener 메소드를 사용하여 이벤트 리스너를 추가했습니다. 
이벤트 리스너 함수는 두 개의 파라미터를 필요로 합니다. 첫 번째 파라미터로는 이벤트의 타입인 
“클릭”이고 두 번째 파라미터는 버튼이 클릭되었을 때 메시지를 남기는 콜백 함수입니다.


⇒ dispatcher-servlet.xml에 등록해야함

⇒ 컨트롤러 매핑url에 유익하게 쓰임

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c62f2b3c-9d98-4748-877f-b9b66f19bba9/Untitled.png)

⇒ 회사코드도 참조

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5f8a6453-8598-4467-869e-dcfa58a9dd64/Untitled.png)

⇒ .do가 호출되기 위해서는 index.html에 text/javascript형식의 스크립트의 문서경로를 지정해둬야한다.

> tip!
> 
> 
> <script type="text/javascript"> 의 의미 ?
> 
> 텍스트를 통해 자바스크립트를 구현하겠다는 뜻
> 
> ...
> 
> HTML 문서에 자바스크립트를 로딩하는 방법에는 3가지 정도가 있는데
> 
> 1. <script type="text/javascript">
> 2. <script language="javascript">
> 3. <script>
> 
> # **결론**
> 
> **표준 => 1**
> 
> **3으로 작성하면 브라우저마다 기본 설정된 값으로 해석됨**
> 
> **HTML5 이상부터는 3으로 표기해도 1로 해석**
> 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/41ad4744-8c6f-4c93-ba05-c0dc97590906/Untitled.png)

##servletMapping지정

하지만 어노테이션 컨트롤러는 자동으로 서블릿매핑을 해준다.

## **서블릿 매핑(Servlet Mapping) 이란?**

**예를 들어 설명하자면,**

**작성한 servlet에 접근을 하기 위해 해당 servlet에 패키지명부터 클래스명까지**

**모두 입력해주어야 한다.**

**이렇게 된다면 보안상의 문제(디렉토리 구조 노출)와**

**접근의 불편함(클래스명을 다 입력해주어야 함)이 있다.**

**이때 개발자가 간단한 URL을 접목시켜 위의 불편사항들을 해결할 수 있다.**

**이것이 서블릿 매핑이다.**
##list.list.do가 호출되는 원리

원래 dispatcher-sevlet에서는 url 기본 매핑이 /WEB-INF/jsp/ .jsp 로 호출되게 되어있다(아래회사코드 참조)

```xml
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
	    <property name="order" value="1" />
		<property name="prefix" value="/WEB-INF/jsp/" />
		<property name="suffix" value=".jsp" />
</bean>
```

자 그럼 화면 호출이 어떻게 되는지 생각해보자

기본적으로 화면을 부르면 기본jsp페이지가 로드 될 것이다. 하지만 그전에 우리는 HttpServeltRequest와 response를 통해 기본페이지가 로드되면 우리는 [list.do](http://list.do) url을 던진다. 우리는 그걸 컨트롤러에서 RequestMapping어노테이션으로 서블릿매핑 한다.
