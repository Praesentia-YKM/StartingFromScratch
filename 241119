- Http의 발전
    - Basic Authentication
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/61a5c6bf-7a59-4970-897f-bce1b48b7ca4/fb1fe656-5910-43c5-adc1-1fbc9f4a0cb9/image.png)
        
        URL 앞쪽에 계정 정보(`user:password`)가 포함되는 이유는 HTTP 프로토콜에서 **기본 인증(Basic Authentication)** 방식을 사용하는 경우에 자격 증명을 포함하여 요청을 보내기 위해서입니다.
        
        ---
        
        ### **1. URL 앞에 계정 정보가 붙는 이유**
        
        ### **Basic Authentication 방식**
        
        - Basic Authentication은 HTTP 프로토콜의 표준 인증 방식 중 하나로, 클라이언트가 서버에 요청을 보낼 때 사용자 이름과 비밀번호를 함께 전송하는 방식입니다.
        - 계정 정보를 URL에 포함하는 형식은 다음과 같습니다:
            
            ```
            http://<username>:<password>@<hostname>/<path>
            
            ```
            
        
        ### **구성 요소**
        
        - **`user:1q2w3e!`**: `user`는 사용자 이름, `1q2w3e!`는 비밀번호입니다.
        - **`@www.cocktailpick.com`**: 서버의 호스트 이름.
        - **`/login`**: 요청하는 리소스(로그인 경로).
        
        ---
        
        ### **2. 이 방식이 동작하는 과정**
        
        ### **(1) URL에 계정 정보 포함**
        
        - 클라이언트는 URL에 `user:password` 정보를 포함하여 요청을 보냅니다.
            
            ```
            GET <http://user:password@www.example.com/resource>
            
            ```
            
        
        ### **(2) Base64로 인코딩**
        
        - HTTP Basic Authentication은 사용자 이름과 비밀번호를 **Base64**로 인코딩한 뒤 `Authorization` 헤더에 포함하여 서버로 전송합니다.
            - 예: `user:password` → Base64로 인코딩 → `dXNlcjpwYXNzd29yZA==`
            - 전송되는 요청 헤더:
                
                ```
                Authorization: Basic dXNlcjpwYXNzd29yZA==
                
                ```
                
        
        ### **(3) 서버에서 인증**
        
        - 서버는 요청의 `Authorization` 헤더를 확인하여 Base64로 디코딩한 후 사용자 이름과 비밀번호를 확인합니다.
        - 인증이 성공하면 요청을 처리하고, 실패하면 401 Unauthorized 상태 코드를 반환합니다.
        
        ---
        
        ### **3. 이 방식의 문제점**
        
        ### **보안 취약점**
        
        - **평문 노출 가능성:**
            - Base64는 암호화가 아니라 단순히 데이터를 인코딩하는 방식입니다. 따라서 Base64로 인코딩된 정보는 쉽게 디코딩할 수 있어, 네트워크에서 요청이 탈취되면 계정 정보가 노출됩니다.
        - **HTTPS 미사용 시 문제:**
            - HTTP를 통해 전송하면 요청이 암호화되지 않으므로, 중간자 공격(Man-In-The-Middle Attack)으로 자격 증명이 쉽게 노출될 수 있습니다.
        
        ### **권장하지 않는 이유**
        
        - 이 방식은 초창기 웹에서 간단한 인증 목적으로 사용되었으나, 보안 문제가 커지면서 현재는 거의 사용되지 않습니다.
        - 대신에 OAuth, JWT 같은 더 안전한 인증 방식을 사용하는 것이 일반적입니다.
        
        ---
        
        ### **4. 보안 강화 방안**
        
        1. **HTTPS 사용**
            - Basic Authentication을 사용해야 한다면 반드시 HTTPS를 통해 요청을 암호화해야 합니다.
        2. **쿠키나 세션 기반 인증**
            - 로그인 후 쿠키나 세션 ID를 통해 인증 상태를 유지합니다.
        3. **JWT (JSON Web Token)**
            - 상태 비저장 방식으로, 클라이언트가 서버와의 요청에 JWT를 포함하여 인증합니다.
        4. **OAuth 2.0**
            - 외부 인증 제공자를 활용하여 사용자 인증을 수행하고 토큰을 발급받아 사용하는 방식입니다.
        
        ---
        
        ### **5. 시각적으로 표현한 요청 흐름**
        
        ```
        클라이언트 → HTTP 요청
          - URL: <http://user:password@www.example.com>
          - Header: Authorization: Basic dXNlcjpwYXNzd29yZA==
        서버 → HTTP 응답
          - 인증 성공: 200 OK
          - 인증 실패: 401 Unauthorized
        
        ```
        
        ---
        
        ### **6. 결론**
        
        URL 앞에 계정 정보가 붙는 이유는 HTTP Basic Authentication 방식을 사용하는 경우 계정 정보를 요청에 포함시키기 위해서입니다. 그러나 이 방식은 보안상 취약하므로, 현대적인 시스템에서는 잘 사용되지 않으며, OAuth, JWT와 같은 보안이 강화된 인증 방식을 사용하는 것이 더 적합합니다.
        
    
    → 사용자가 매번 로그인(인증)을 해줘야하는 단점이 발생함
    
    → 따라서 Brower의 스토리지(세션, 쿠키)의 힘을 빌림
    
    - 쿠키 방식
        
        > 쿠키를 사용하면 **상태를 유지**할 수 있다는 점에서 더 나은 사용자 경험을 제공합니다.
        > 
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/61a5c6bf-7a59-4970-897f-bce1b48b7ca4/b34c319c-08d8-42b3-b067-19c6a683726e/image.png)
        
        이미지를 바탕으로 설명하자면, 이 방식은 **Basic Authentication**의 단점을 보완하려고 **쿠키를 사용**하여 상태를 관리하는 방식처럼 보입니다. 질문하신 대로 **쿠키를 활용하는 방식**은 기존 Basic Authentication의 매번 자격 증명을 포함해야 하는 단점을 해결하는 방법 중 하나입니다. 하지만 단순히 쿠키를 헤더에 실어 보낸다는 점에서만 차이 나는 것은 아닙니다. 쿠키를 사용하면 **상태를 유지**할 수 있다는 점에서 더 나은 사용자 경험을 제공합니다.
        
        ---
        
        ### **1. Basic Authentication 방식의 단점**
        
        1. **매번 자격 증명 전송**:
            - Basic Authentication에서는 모든 요청에 사용자 이름과 비밀번호를 Base64로 인코딩한 후 `Authorization` 헤더에 포함해 서버에 전송합니다.
            - 이는 사용자 비밀번호를 매번 네트워크를 통해 전송하게 되어, **보안 위험**이 증가합니다.
        2. **로그인 상태 유지 불가**:
            - 인증 정보를 저장하거나 세션을 관리하지 않으므로, 클라이언트가 요청할 때마다 인증을 반복해야 합니다.
            - 사용자가 한 번 인증하면, 이후 인증 정보를 다시 제공하지 않아도 되는 방식이 필요합니다.
        
        ---
        
        ### **2. 쿠키를 활용한 인증 방식**
        
        쿠키를 활용하면, Basic Authentication의 단점을 해결하며 상태를 유지할 수 있습니다.
        
        ### **동작 방식:**
        
        1. **로그인 시 인증 토큰 발급**:
            - 사용자가 로그인하면 서버는 클라이언트를 인증하고, 세션 ID 또는 토큰을 발급합니다.
            - 이 정보는 **Set-Cookie** 헤더를 통해 클라이언트에게 전달됩니다.
        2. **쿠키로 인증 상태 유지**:
            - 클라이언트는 이후 요청마다 해당 쿠키를 포함시켜 서버에 보냅니다.
            - 서버는 쿠키에 저장된 정보를 검증하여 사용자를 인증합니다.
        
        ### **구현 흐름:**
        
        - **로그인 요청**:
            - 클라이언트 → 서버로 자격 증명(ID, PW) 전송.
            - 서버는 자격 증명을 검증 후, 쿠키에 세션 ID 또는 토큰을 담아 응답.
        - **이후 요청**:
            - 클라이언트는 쿠키를 자동으로 포함하여 요청.
            - 서버는 쿠키를 확인해 인증 상태를 판단.
        
        ---
        
        ### **3. 쿠키 방식의 장점**
        
        1. **로그인 상태 유지**:
            - 클라이언트는 인증 정보를 반복적으로 입력할 필요가 없습니다.
            - 서버는 쿠키를 활용하여 사용자의 인증 상태를 유지할 수 있습니다.
        2. **보안 향상**:
            - 비밀번호를 매번 전송하지 않고, 대신 세션 ID 또는 토큰을 전송하므로 네트워크에서 비밀번호 탈취 위험이 줄어듭니다.
        3. **유연한 상태 관리**:
            - 쿠키를 통해 세션 ID, 인증 토큰, 사용자 설정 등 다양한 정보를 관리할 수 있습니다.
        
        ---
        
        ### **4. Basic Authentication + 쿠키 비교**
        
        | **항목** | **Basic Authentication** | **쿠키를 사용한 인증** |
        | --- | --- | --- |
        | **인증 정보 전송 빈도** | 요청마다 사용자 ID와 비밀번호를 전송 | 최초 로그인 이후 쿠키를 통해 인증 상태 유지 |
        | **보안 위험성** | 비밀번호가 네트워크를 통해 반복적으로 전송됨 | 쿠키에 세션 ID나 토큰만 포함하므로 비밀번호는 전송되지 않음 |
        | **상태 유지** | 상태를 유지하지 않음 (Stateless) | 상태를 유지함 (Stateful) |
        | **사용자 경험** | 요청마다 재인증 필요 | 로그인 상태 유지, 재인증 불필요 |
        
        ---
        
        ### **5. 보안 측면에서의 쿠키 인증**
        
        쿠키를 활용할 때도 추가적인 보안 강화 조치가 필요합니다. 아래는 몇 가지 방법입니다:
        
        1. **쿠키의 Secure 옵션**:
            - HTTPS 연결에서만 쿠키가 전송되도록 설정합니다.
            
            ```
            Set-Cookie: sessionId=abc123; Secure; HttpOnly;
            
            ```
            
        2. **HttpOnly 속성**:
            - 쿠키가 클라이언트의 JavaScript로 접근되지 않도록 설정하여 XSS(교차 사이트 스크립팅) 공격을 방지합니다.
        3. **SameSite 옵션**:
            - 쿠키가 동일한 사이트에서만 전송되도록 설정하여 CSRF(Cross-Site Request Forgery) 공격을 방지합니다.
            
            ```
            Set-Cookie: sessionId=abc123; SameSite=Strict;
            
            ```
            
        4. **쿠키 만료 시간 설정**:
            - 세션 쿠키의 만료 시간을 설정하여 쿠키가 일정 시간 이후 자동으로 삭제되도록 만듭니다.
        5. **세션 저장소 관리**:
            - 서버는 세션 ID를 기반으로 사용자 상태를 관리하며, Redis와 같은 저장소를 사용해 고속 처리를 지원할 수 있습니다.
        
        ---
        
        ### **6. 결론**
        
        - 기본적으로 **쿠키를 활용한 인증 방식**은 Basic Authentication의 반복적인 인증 요청 문제를 해결하고, 사용자의 로그인 상태를 유지할 수 있는 더 나은 방식입니다.
        - 쿠키를 사용하면 **상태 관리(Stateful)**가 가능하며, 이를 통해 인증 토큰이나 세션 정보를 보안성 있게 전달할 수 있습니다.
        - 다만 쿠키를 사용할 때도 보안 강화 옵션(Secure, HttpOnly, SameSite 등)을 설정하여 쿠키 자체가 노출되는 위험을 방지해야 합니다.
        
        추가적으로 JWT, OAuth 같은 최신 인증 방식을 조합하면 더 강력한 보안을 구현할 수 있습니다. 😊
        
    - 세션 방식
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/61a5c6bf-7a59-4970-897f-bce1b48b7ca4/7214d30c-f85f-4ffc-9be2-e3a5e479c4a9/image.png)
        
        이미지에서 설명된 방식은 **세션(Session)을 활용한 인증 방식**입니다. 이 방식은 서버가 클라이언트의 상태를 유지하기 위해 **세션 ID**를 발급하고, 클라이언트가 요청마다 이 세션 ID를 통해 인증을 수행하는 방식입니다. 이는 **Basic Authentication**의 단점(매번 자격 증명을 전송해야 함)을 해결하면서도 서버 측에서 사용자의 상태를 관리할 수 있게 합니다.
        
        ---
        
        ### **1. 세션(Session)을 활용한 인증 방식**
        
        ### **동작 과정**
        
        1. **로그인 요청**:
            - 클라이언트는 사용자 ID와 비밀번호를 서버로 보냅니다.
            - 예: `Authorization: Basic dG9uZXk6cGFzc3dvcmQ` (Base64로 인코딩된 ID와 비밀번호).
        2. **서버에서 인증 처리**:
            - 서버는 데이터베이스에서 사용자 정보를 확인한 뒤, 인증에 성공하면 **세션 ID**를 생성합니다.
            - 이 세션 ID는 서버에 저장됩니다.
        3. **클라이언트에 세션 ID 발급**:
            - 서버는 생성한 세션 ID를 쿠키(`Set-Cookie`)에 담아 클라이언트에게 전달합니다.
            - 예: `Set-Cookie: JSESSIONID=aFs28X1ka1d`
        4. **이후 요청**:
            - 클라이언트는 이후 모든 요청에 쿠키를 자동으로 포함하여 서버에 전송합니다.
            - 서버는 요청에 포함된 세션 ID를 기반으로 사용자를 식별합니다.
        
        ---
        
        ### **2. 세션 기반 인증의 특징**
        
        ### **장점**:
        
        1. **상태 유지**:
            - 서버가 사용자의 상태를 관리하므로, 클라이언트는 매번 자격 증명을 보낼 필요가 없습니다.
            - 클라이언트는 세션 ID만 포함된 쿠키를 전송하면 됩니다.
        2. **보안성**:
            - 비밀번호는 최초 로그인 시 한 번만 전송되며, 이후에는 세션 ID만 사용하므로 네트워크 상에서 비밀번호가 노출될 위험이 줄어듭니다.
        3. **서버 측 통제**:
            - 세션 정보를 서버에서 관리하므로, 특정 세션을 강제로 만료시킬 수 있습니다(예: 로그아웃, 세션 타임아웃 등).
        
        ### **단점**:
        
        1. **서버 부담 증가**:
            - 서버는 모든 클라이언트의 세션 상태를 저장하고 관리해야 하므로, 대규모 트래픽 환경에서는 리소스 사용량이 늘어날 수 있습니다.
            - 이를 해결하기 위해 Redis 같은 캐시 서버를 활용할 수 있습니다.
        2. **분산 환경에서 복잡성 증가**:
            - 서버가 여러 대인 경우(로드 밸런싱) 세션 정보를 공유해야 하므로 추가적인 복잡성이 필요합니다.
        
        ---
        
        ### **3. 세션 방식과 기존 Basic Authentication 비교**
        
        | **항목** | **Basic Authentication** | **Session Authentication** |
        | --- | --- | --- |
        | **상태 유지 여부** | 상태를 유지하지 않음 (Stateless) | 상태를 유지함 (Stateful) |
        | **요청 정보** | 매번 사용자 ID와 비밀번호 전송 | 세션 ID만 전송 |
        | **보안 위험** | 비밀번호 탈취 위험 존재 | 세션 ID 탈취 위험 (쿠키 보안 강화 필요) |
        | **서버 관리 부담** | 서버는 요청별로 인증만 수행 | 서버가 세션 상태를 저장하고 관리 |
        | **사용자 경험** | 매 요청마다 인증 필요 | 한 번 로그인 후 인증 상태 유지 |
        
        ---
        
        ### **4. 보안 강화 방안**
        
        세션 기반 인증에서 보안성을 높이기 위해 아래와 같은 방안을 적용할 수 있습니다:
        
        1. **쿠키 보안 속성 설정**:
            - **Secure**: HTTPS를 통해서만 쿠키 전송.
            - **HttpOnly**: 클라이언트의 JavaScript가 쿠키에 접근하지 못하도록 설정.
            - **SameSite**: CSRF 방지를 위해 쿠키를 동일 사이트 요청에서만 전송.
            
            ```
            Set-Cookie: JSESSIONID=aFs28X1ka1d; Secure; HttpOnly; SameSite=Strict
            
            ```
            
        2. **세션 타임아웃**:
            - 세션의 유효 기간을 설정하여 오랜 시간 비활성 상태인 세션을 자동으로 만료시킴.
            - 예: 30분 동안 활동이 없으면 세션 삭제.
        3. **로그아웃 시 세션 삭제**:
            - 클라이언트가 로그아웃하면 서버에서 해당 세션을 삭제해 더 이상 유효하지 않도록 설정.
        4. **CSRF 방지**:
            - CSRF 토큰을 활용하여 요청의 유효성을 추가적으로 검증.
        5. **Redis를 활용한 세션 관리**:
            - 대규모 트래픽 환경에서는 Redis와 같은 인메모리 데이터베이스를 활용해 세션 상태를 빠르게 저장하고 관리.
        
        ---
        
        ### **5. 세션 방식의 동작 흐름 시각화**
        
        ```
        1. 로그인 요청:
           [클라이언트] → HTTP 요청 (ID, PW) → [서버]
        
        2. 인증 성공:
           [서버] → 세션 생성 (JSESSIONID) → [세션 저장소]
        
        3. 세션 ID 전달:
           [서버] → Set-Cookie: JSESSIONID=aFs28X1ka1d → [클라이언트]
        
        4. 이후 요청:
           [클라이언트] → HTTP 요청 + Cookie: JSESSIONID=aFs28X1ka1d → [서버]
           [서버] → 세션 확인 후 응답
        
        ```
        
        ---
        
        ### **6. 결론**
        
        - **세션 기반 인증**은 서버가 사용자의 상태를 관리하며, 로그인 상태를 유지할 수 있는 효율적인 방식입니다.
        - Basic Authentication의 단점을 해결하며, 보안이 강화된 방식입니다.
        - 하지만 서버에서 세션 정보를 관리해야 하므로, 대규모 서비스에서는 Redis와 같은 외부 저장소를 활용하거나 JWT 기반 인증으로 확장할 수도 있습니다.
        - 사용 목적과 규모에 따라 적합한 인증 방식을 선택하는 것이 중요합니다. 😊
    - 쿠키던 세션이던 결국 쿠키이용하는데 뭐가 다른거야
        
        이전에 설명한 **"쿠키를 사용하는 인증 방식"**과 **"세션 기반 인증 방식"**은 모두 쿠키를 활용하지만, **쿠키의 역할과 데이터 저장 위치**에서 차이가 있습니다. 이를 비교하면 두 방식의 근본적인 차이를 이해할 수 있습니다.
        
        ---
        
        ### **1. 주요 차이점: 쿠키와 세션 기반 인증**
        
        | **항목** | **쿠키를 사용하는 인증 (JWT 기반)** | **세션 기반 인증** |
        | --- | --- | --- |
        | **쿠키에 저장되는 정보** | 인증에 필요한 **JWT 토큰** 또는 상태 정보 자체가 저장됨 | 세션 ID(식별자)만 저장되고, 세션 데이터는 서버에 저장 |
        | **상태 저장 위치** | 클라이언트 측 (JWT를 클라이언트가 보관) | 서버 측 (세션 데이터를 서버에서 관리) |
        | **서버 부하** | 서버는 JWT를 검증만 하면 되므로 부하가 적음 | 세션 데이터를 서버에서 관리하므로 부하가 증가 |
        | **확장성** | 상태 비저장(stateless)이므로 서버 확장이 용이함 | 상태 저장(stateful)이므로 서버 확장이 복잡함 |
        | **로그아웃 처리** | 클라이언트의 JWT 토큰을 삭제해야 함 | 서버에서 세션 ID를 삭제하면 즉시 로그아웃 처리 가능 |
        | **보안** | JWT 자체가 암호화되지 않으면 클라이언트 측에서 위험 | 세션 데이터는 서버에 있으므로 보안이 더 강력함 |
        
        ---
        
        ### **2. 쿠키 인증 방식의 동작 (JWT 기반)**
        
        ### **동작 과정:**
        
        1. **로그인 시 JWT 발급**:
            - 사용자가 로그인하면 서버는 JWT를 생성하여 클라이언트로 반환합니다.
            - 이 JWT는 사용자의 인증 상태를 표현하며, 필요 시 인가 정보(예: 사용자 역할 등)를 포함할 수 있습니다.
        2. **JWT 저장**:
            - 클라이언트는 JWT를 **쿠키** 또는 **로컬 스토리지**에 저장합니다.
            - 이후 모든 요청에서 이 JWT를 포함해 서버에 보냅니다.
        3. **요청 처리**:
            - 서버는 요청에 포함된 JWT를 확인하고, 서명을 검증한 후 사용자를 인증합니다.
            - 서버는 별도의 세션 데이터를 유지하지 않습니다.
        
        ### **장점:**
        
        - 상태 비저장(stateless)이므로 서버 확장이 용이.
        - 클라이언트가 상태 정보를 보관하므로 서버가 세션 데이터를 유지할 필요 없음.
        
        ### **단점:**
        
        - 로그아웃 처리나 토큰 무효화가 어렵습니다(JWT는 기본적으로 만료 전까지 유효).
        - 클라이언트가 JWT를 안전하게 저장하지 않으면 탈취 위험이 있습니다.
        
        ---
        
        ### **3. 세션 기반 인증 방식**
        
        ### **동작 과정:**
        
        1. **로그인 시 세션 생성**:
            - 사용자가 로그인하면 서버는 세션 ID를 생성하고, 세션 데이터(예: 사용자 정보)를 서버 메모리나 데이터베이스에 저장합니다.
        2. **세션 ID 저장**:
            - 서버는 클라이언트로 세션 ID를 반환하며, 이 세션 ID는 클라이언트의 쿠키에 저장됩니다.
            - 이후 클라이언트는 요청마다 쿠키를 통해 세션 ID를 서버에 전송합니다.
        3. **요청 처리**:
            - 서버는 요청에 포함된 세션 ID를 확인하고, 서버에 저장된 세션 데이터와 비교하여 사용자를 인증합니다.
        
        ### **장점:**
        
        - 로그아웃 처리와 세션 무효화가 용이합니다.
        - 서버에서 상태를 관리하므로 클라이언트에서 데이터가 탈취되더라도 즉시 세션을 만료시킬 수 있습니다.
        
        ### **단점:**
        
        - 상태 저장(stateful)이므로 서버가 모든 세션 데이터를 관리해야 하며, 리소스가 증가합니다.
        - 로드 밸런싱된 환경에서는 세션 데이터를 공유하거나 Redis와 같은 외부 세션 저장소를 사용해야 합니다.
        
        ---
        
        ### **4. 쿠키의 역할 비교**
        
        ### **JWT 기반 쿠키 인증**:
        
        - 쿠키에는 **JWT(상태 정보)**가 저장됩니다.
        - 쿠키는 단순히 데이터를 클라이언트가 보관하고 요청마다 전달하는 매개체 역할을 합니다.
        - 서버는 쿠키에 포함된 JWT를 검증하는 데만 사용됩니다(상태는 서버에 저장되지 않음).
        
        ### **세션 기반 쿠키 인증**:
        
        - 쿠키에는 **세션 ID**만 저장됩니다.
        - 쿠키는 클라이언트를 식별하기 위한 키(key) 역할만 합니다.
        - 세션 데이터는 서버에 저장되며, 쿠키는 이를 식별하는 도구로만 사용됩니다.
        
        ---
        
        ### **5. 어떤 상황에서 어떤 방식을 선택해야 할까?**
        
        ### **JWT 기반 쿠키 인증이 적합한 경우**:
        
        1. 서버가 상태를 저장하지 않아야 하는 경우.
        2. 확장성(서버 간 로드 밸런싱)이 중요한 경우.
        3. RESTful API와 같은 무상태 프로토콜을 사용하는 경우.
        
        ### **세션 기반 인증이 적합한 경우**:
        
        1. 보안이 중요한 경우(서버가 모든 상태를 관리하므로 더 안전).
        2. 사용자가 로그아웃하거나 세션을 무효화해야 하는 경우.
        3. 단일 서버 또는 Redis 같은 중앙 세션 저장소를 사용할 수 있는 경우.
        
        ---
        
        ### **6. 요약**
        
        - *이전 설명에서 말한 "쿠키 인증"**은 클라이언트에 상태 정보를 저장(JWT)하며, 서버는 이를 검증하기만 합니다. 서버는 상태를 기억하지 않으므로 상태 비저장 방식입니다.
        - **세션 인증**에서는 쿠키에 **세션 ID**만 저장하며, 실제 상태 정보는 서버에서 관리합니다. 서버는 클라이언트의 상태를 유지하고 직접 관리하므로 더 안전하지만 리소스가 더 필요합니다.
        - 두 방식 모두 쿠키를 사용하지만, 쿠키에 저장되는 데이터와 인증 상태를 유지하는 방식에서 차이가 있습니다.
        
        이 차이점을 염두에 두고, 시스템의 요구사항과 확장성을 고려하여 적합한 방식을 선택하면 됩니다! 😊
        
    - 세션방식과 쿠키 방식의 각각 장단점
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/61a5c6bf-7a59-4970-897f-bce1b48b7ca4/4ed8bb6c-6d81-4cc1-9ece-ab09c66231d8/image.png)
        
        **JWT (쿠키)기반 인증**과 **세션 기반 인증**은 각각의 장단점이 있기 때문에, **특정 상황과 요구사항**에 따라 더 적합한 방식이 달라집니다. 두 방식은 상호 배타적이지 않으며, **시스템의 구조, 확장성, 보안 요구사항**에 따라 선택해야 합니다. 아래에 각 방식이 유리한 상황과 이점을 정리해 드리겠습니다.
        
        ---
        
        ### **1. 세션 기반 인증: Stateful**
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/61a5c6bf-7a59-4970-897f-bce1b48b7ca4/3d955d98-e24d-4e6c-aa71-c86cf325b967/image.png)
        
        ### **장점**
        
        1. **서버 중심 관리**:
            - 세션 정보가 서버에 저장되므로, 서버가 세션의 생애주기를 완전히 제어할 수 있습니다.
            - 사용자가 로그아웃하거나 세션이 만료되면 즉시 세션 ID를 삭제하여 보안을 강화할 수 있습니다.
        2. **보안 강화**:
            - 민감한 정보는 서버에만 저장되므로 클라이언트에서 데이터 탈취 위험이 줄어듭니다.
            - 세션 ID는 단순 식별자로 사용되며, 암호화된 데이터를 클라이언트에 저장하지 않습니다.
        3. **로그아웃 및 세션 무효화가 쉬움**:
            - 서버에서 특정 세션을 제거하면 모든 클라이언트 요청이 즉시 인증 실패 처리됩니다.
            - 예: 관리자가 강제로 로그아웃 처리.
        
        ### **단점**
        
        1. **확장성 문제**:
            - 서버가 모든 클라이언트의 세션을 저장하므로, 사용자 수가 증가하면 서버의 메모리 사용량이 증가합니다.
            - 로드 밸런싱된 환경에서는 세션 데이터를 공유하거나 외부 저장소(Redis 등)를 사용해야 하므로 복잡성이 증가합니다.
        2. **네트워크 오버헤드**:
            - 서버는 세션을 유지하기 위해 매번 세션 저장소에 접근해야 하므로 부하가 커질 수 있습니다.
        
        ### **언제 유리한가?**
        
        - **보안이 중요한 경우**:
            - 로그아웃, 세션 만료, 강제 만료 같은 기능이 필요할 때.
            - 클라이언트가 탈취된 토큰을 사용하지 못하게 즉시 차단해야 할 때.
        - **단일 서버 또는 세션 공유 가능 환경**:
            - 단일 서버에서 동작하거나 Redis와 같은 빠른 세션 저장소를 사용할 수 있을 때.
        - **상태 기반 작업이 많은 경우**:
            - 로그인 이후에 사용자의 여러 상태(예: 쇼핑몰의 장바구니, 주문 내역 등)를 서버에서 관리해야 할 때.
        
        ---
        
        ### **2. JWT 기반 인증: Stateless**
        
        ### **장점**
        
        1. **확장성**:
            - JWT는 상태 비저장 방식이므로, 서버는 인증 상태를 유지할 필요가 없습니다.
            - 로드 밸런싱된 서버 환경에서도 중앙 세션 저장소 없이도 동작합니다.
            - 서버가 분산되어 있거나 서버 간 통신 비용을 줄이고 싶을 때 적합합니다.
        2. **효율성**:
            - 서버는 JWT를 검증하기만 하면 되므로, 인증 상태 확인에 필요한 리소스가 적습니다.
            - RESTful API 같은 무상태 프로토콜과 잘 어울립니다.
        3. **클라이언트 중심 인증**:
            - 클라이언트가 JWT를 보관하고, 이를 포함해 요청을 보내므로 서버는 인증 정보를 저장하지 않아도 됩니다.
        
        ### **단점**
        
        1. **로그아웃/무효화의 어려움**:
            - JWT는 기본적으로 만료 시간(`exp`)까지 유효하며, 한 번 발급된 토큰을 서버가 강제로 무효화하기 어렵습니다.
            - 이를 해결하려면 추가적으로 Redis나 블랙리스트를 관리해야 합니다.
        2. **클라이언트 보안 취약성**:
            - JWT가 클라이언트에 저장되므로, 탈취될 경우 사용자가 피해를 입을 가능성이 있습니다.
            - 쿠키 보안 옵션(Secure, HttpOnly) 또는 로컬 스토리지 보안이 필수적입니다.
        
        ### **언제 유리한가?**
        
        - **확장성과 분산 서버 환경**:
            - 상태를 서버에서 유지하지 않아도 되므로, 대규모 트래픽에서 더 효율적입니다.
            - 마이크로서비스 아키텍처에서 인증 상태를 공유할 때 유리합니다.
        - **RESTful API 설계**:
            - 클라이언트-서버 간 상태를 유지하지 않는 RESTful API에서 사용하기 적합합니다.
        - **리소스 효율성이 중요한 경우**:
            - 인증 상태를 유지하기 위해 추가적인 세션 저장소를 사용하지 않아도 되므로 서버 부하를 줄일 수 있습니다.
        
        ---
        
        ### **3. 선택 기준: 언제 어떤 방식을 사용할까?**
        
        ### **1) 시스템 확장성 고려**
        
        - **대규모 트래픽 또는 분산 서버 환경**:
            - ✅ **JWT 기반 인증**: 서버 간 세션 데이터 공유 필요 없이 확장 가능.
            - ❌ 세션 기반은 Redis 등 세션 공유 설정 필요.
        - **소규모 또는 단일 서버 환경**:
            - ✅ **세션 기반 인증**: 단순 구현 및 보안 관리 용이.
            - ❌ JWT는 과도한 엔지니어링일 수 있음.
        
        ### **2) 보안 요구사항**
        
        - **즉시 로그아웃, 세션 강제 만료 필요**:
            - ✅ **세션 기반 인증**: 서버에서 세션 데이터를 즉시 삭제 가능.
            - ❌ JWT는 기본적으로 토큰 만료 전까지는 유효.
        - **민감한 데이터 보호**:
            - ✅ **세션 기반 인증**: 민감한 데이터는 서버에만 저장.
            - ❌ JWT는 클라이언트 보안 설정에 크게 의존.
        
        ### **3) 사용 사례**
        
        - **웹 애플리케이션 (로그인 상태 유지 중요)**:
            - 세션 기반 인증이 적합(예: 쇼핑몰, 관리 시스템).
        - **API 인증 (다양한 클라이언트 지원)**:
            - JWT 기반 인증이 적합(예: 모바일 앱, 분산 API).
        
        ---
        
        ### **4. 정리: 어떤 방식이 더 나은가?**
        
        | **요구사항/상황** | **추천 방식** | **이유** |
        | --- | --- | --- |
        | **사용자 상태를 서버에서 관리해야 함** | 세션 기반 인증 | 로그아웃, 세션 만료 처리 가능, 민감 데이터 서버 관리 |
        | **서버 확장성과 성능이 중요** | JWT 기반 인증 | 상태 비저장(stateless), 서버 확장 용이 |
        | **RESTful API 또는 모바일 클라이언트** | JWT 기반 인증 | 클라이언트-서버 간 상태 유지 필요 없음 |
        | **민감한 데이터 보호 우선** | 세션 기반 인증 | 인증 데이터가 클라이언트에 저장되지 않음 |
        | **즉각적인 로그아웃 및 강제 만료 필요** | 세션 기반 인증 | 세션 ID 삭제로 빠르게 로그아웃 처리 가능 |
        
        ---
        
        ### **5. 결론**
        
        두 방식 모두 상황에 따라 적합한 경우가 있으며, 어느 하나가 절대적으로 우월하지는 않습니다.
        
        - **작은 규모의 애플리케이션**이나 **보안이 최우선**인 시스템이라면 **세션 기반 인증**이 적합합니다.
        - 반면, **확장성**, **분산 서버**, 또는 **RESTful API**가 중심인 시스템에서는 **JWT 기반 인증**이 더 유리합니다.
        
        최적의 선택은 **시스템 요구사항**과 **목표**를 기반으로 결정해야 합니다. 😊
        
    - JWT의 단점 보안
        
        ### **세션 방식의 장점을 JWT에서 구현할 수 있는가?**
        
        | **JWT 단점** | **세션 방식 장점** | **JWT에서 보완 방법** |
        | --- | --- | --- |
        | **토큰 탈취 시 즉시 차단 불가** | 세션은 서버에서 삭제 가능 | 블랙리스트 관리, 짧은 만료 시간 + Refresh Token |
        | **로그아웃 처리 어려움** | 세션 삭제로 즉시 로그아웃 가능 | Refresh Token 삭제로 로그아웃 구현 |
        | **서버 측 상태 관리 부족** | 서버가 모든 상태를 유지 | Refresh Token 저장소 활용, 서버-클라이언트 간 토큰 동기화 |
        | **기기 간 세션 공유 문제** | 세션 ID로 모든 기기에서 동기화 가능 | JWT에 기기 식별 정보(`aud`, `jti`) 추가, 특정 기기만 토큰 무효화 |
    - ACCESS TOKEN
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/61a5c6bf-7a59-4970-897f-bce1b48b7ca4/959cbd34-98b3-4fb9-a9fc-63e05407a30d/image.png)
