7.3 무결성 제약 정의
7.3.1 입력참조 무결성
1.각 테이블에 레코드가 입력될 때 자신이 참조하고 있는 테이블의 PK에 대해 데이타의 정합성을 일치시켜 주는기능이다.
2.입력참조 무결성을 유지하기 위한 6가지 기능
1)의존:테이블에 데이타가 입력될 때 참조하고 있는 테이블의 PK가 존재해야만 데이타 입력이 가능하다.
2)자동:테이블에 데이타가 입력될 때 참조하고 있는 테이블의 PK가 존재하지 않으면 참조테이블에 PK를 생성하고 데이타를 입력한다.
3)기본:테이블에 데이타가 입력될 때 참조하고 있는 테이블의 PK를 기본값으로 바꾼 후 입력한다 (?)무슨 의미인가?
4)지정:사용자가 지정해 놓은 일정한 조건을 만족한 이후에 테이블에 레코드를 입력한다.
5)NULL:테이블에 데이타가 입력될 때 참조하고 있는 테이블의 PK가 없다면 NULL값으로 입력한다.
6)미지정:테이블에 데이타가 입력될 때 참조하고 있는 테이블의 PK가 없다면 NULL값으로 입력한다. (?) NULL과의 차이점은 무엇인가?


7.3.2 수정참조 무결성
1.한 테이블의 PK가 수정되면 이 테이블을 참조하고 있는 모든 테이블의 FK도 수정하여 데이타의 정합성을 유지하는 기능이다.
2.수정참조 무결성을 유지하기 위한 2가지 기능
1)제한:테이블의 PK를 수정하면 자신을 참조하는 테이블의 FK가 없어야 한다. 테이블의 FK가 존재하면 자신의 테이블의 PK가 수정되지 않는다.
2)연쇄:테이블의 PK를 수정해아 한다면 참조되는 모든 테이블의 FK를 수정한 후 자신의 PK를 수정한다.


7.3.3 삭제참조 무결성
1.어떤 테이블의 PK가 삭제될 때 참조하는 모든 테이블의 FK를 기본값이나 NULL로 수정하여 데이타의 정합성을 유지하는 기능이다.
2.삭제참조 무결성을 유지하기 위한 6가지 기능
1)제한:자신의 테이블의 레코드를 삭제하려면 자신을 참조하는 테이블의 레코드가 없어야 한다. 만약 이러한 레코드가 있다면 삭제해서는 안된다.
2)연쇄:자신의 테이블의 레코드를 삭제하려면 참조하는 모든 테이블의 레코드를 삭제하고 난 후 자신의 레코드를 삭제한다.
3)기본:참조하는 모든 테이블의 레코드를 기본값으로 변경한 후 자신의 레코드를 삭제한다. 주로 비식별자 관계에서 사용한다.
4)지정:사용자가 정의해 놓은 일정한 조건을 만족한 이후에 자신의 레코드를 삭제한다.
5)NULL:참조하는 모든 테이블의 레코드를 NULL로 바꾼 후 자신의 레코드를 삭제한다. 비식별자 관계에서 사용한다.
6)미지정:자신의 테이블의 레코드를 삭제해도 특별한 참조무결성 규칙을 적용하지 않는다. 조건없이 삭제가 가능하다.
(?) 조건없이 삭제가 가능한 것이 어떻게 참조무결성을 유지하는 방법이 될 수가 있는가?


7.3.4 참조무결성 적용시 주의사항
1)한 테이블의 PK가 수정,삭제가 된다면 참조하고 있는 모든 테이블를 무결성 원칙에 따라 점검한다.(PK테이블의 입력는 자유롭다)
2)FK가 있는 테이블에 입력,수정이 일어나면 PK가 있는 테이블에 레코드가 존재하는지 검사한다.(자식테이블에서의 삭제는 자유롭다)
3)이러한 이유로 성능이 저하되는 문제가 발생할 수도 있다.


7.3.5 FK 제약이 걸려 있는 칼럼들의 인덱스 생성
1)FK제약이 걸려있는 칼럼의 경우 인덱스를 생성하는게 좋다. 비록 업무상 그 인덱스를 사용하지 않을지라도 DBMS내부적으로 사용하기 때문이다.
2)<사원>과 <발령>테이블이 사원번호로 연결되어 있는경우 <발령> 테이블의 사원번호에 인덱스를 생성하지 않으면 특정 사원정보가 삭제될 때 DBMS내부적으로는 <발령> 테이블을 풀스캔하여 삭제한 데이타를 찾기때문에 성능에 문제가 될 수 있다.
3)물론 FK의 인덱스도 평균분포도가 10~15%인 컬럼에 대해 지정하는 규칙은 적용된다.
