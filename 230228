PARTITION BY 대 GROUP BY
PARTITION BY와 GROUP BY절은 복잡한 분석을 할 때 꽤나 자주 쓰게 될 SQL 문법입니다. 물론 데이터를 단순히 반환하는 것만으로도 유용할 때가 있겠지만, 우리가 마주하는 상황은 종종 더 복잡한 계산을 하는 상황이기 때문입니다. 한 단계 발전된 분석을 위해 우리는 GROUP BY와 PARTITION BY를 사용합니다. 이 둘은 데이터를 "그룹화"한다는 점에서 유사하지만, 둘 사이에는 아주 큰 차이점이 존재합니다. 그 차이점을 지금부터 살펴보도록 하겠습니다.

 

GROUP BY
GROUP BY 절은 특정 기준으로 데이터를 정의하고자 할 때 사용합니다. 보통 이런 기준은 우리가 분석을 할 때 분류 기준으로 삼는 것들입니다. 예를 들자면, 임직원의 정보를 그들의 '연봉 인상률'을 기준으로 그룹화할 수 있고, 기차 정보를 기차의 '출발역' 기준으로 그룹화할 수 있을 것이며, 매출 정보를 '연도' 및 '월별'로 그룹화하여 살펴볼 수 있습니다. 

GROUP BY 절을 사용하면 기존 행에 있던 데이터는 우리가 제공한 새로운 기준에 의해 생성된 새로운 행에 입력됩니다. 그뿐만이 아닙니다. 집계 함수를 사용하여 기존 행에 있던 값들을 계산한 후 새로운 행에 입력해 줄 수도 있습니다.  집계 함수는 데이터를 하나로 합쳐줍니다. 합치는 과정에서, 우리는 기존의 상세 데이터들을 잃게 됩니다. 집계 함수의 종류는 다양하지만, 그중 가장 많이 사용되는 함수는 COUNT, SUM, AVG, MIN, MAX 함수가 있습니다.

Oracle - 분석함수, PARTITION BY
분석함수
MAX, MIN, COUNT, LAG, LEAD, RANK, RATIO_TO_REPORT, ROW_NUMBER, SUM, AVG 등
ARGS : 0 ~ 3개 까지만 줄 수 있다.
테이블에서 몇줄에서 몇줄가지 그룹핑 해서 정렬한 다음 분석함수로 리턴할 건지를 결정하는 함수
테이블 -> 선택 행 -> 그룹핑 -> 정렬 -> 집계 리턴
[형식] 

SELECT 컬럼명, 컬럼명,,,,,
    분석함수 (ARGS[아규먼트]) OVER (
                                      [PARTITION BY] 쿼리 결과를 그룹으로 묶는다.
                                      [ORDER BY] 각 그룹의 정렬 _행의 겁색 순서_ 옵션_ ASC/DESC/NULL/FIRST/LAST
                                                 EX) DESC NULL FIRST | ASC NULL LAST
                                      [WINDOWING 절] ROWS | RANGE [BETWEEN AND]
                                  )
FROM 테이블명;

실습을 위한 EMP(사원) 테이블
EMPNO	ENAME	JOB	        MGR		HIREDATE	SAL		COMM	DEPTNO
7369	SMITH	CLERK	    7902	80/12/17	800				20
7499	ALLEN	SALESMAN	7698	81/02/20	1600	300		30
7521	WARD	SALESMAN	7698	81/02/22	1250	200		30
7566	JONES	MANAGER	    7839	81/04/02	2975	30		20
7654	MARTIN	SALESMAN	7698	81/09/28	1250	300		30
7698	BLAKE	MANAGER	    7839	81/04/01	2850			30
7782	CLARK	MANAGER	    7839	81/06/01	2450			10
7788	SCOTT	ANALYST	    7566	82/10/09	3000			20
7839	KING	PRESIDENT			81/11/17	5000	3500	10
7844	TURNER	SALESMAN	7698	81/09/08	1500	0		30
7876	ADAMS	CLERK	    7788	83/01/12	1100			20
7900	JAMES	CLERK	    7698	81/10/03	950				30
7902	FORD	ANALYST	    7566	81/10/03	3000			20
7934	MILLER	CLERK	    7782	82/01/23	1300			10

예시01 - MAX
-- 사원번호, 사원명, 직업, 봉급, 최대봉급을 조회하되,
-- 각 사원의 직업별 봉급이 어떤 카테고리에 속해 있는지 확인할 수 있도록 조회해보자.

SELECT EMPNO, ENAME, JOB, SAL,
MAX(SAL) OVER(PARTITION BY JOB)
FROM C##SCOTT.EMP
WHERE JOB IN ('MANAGER', 'SALESMAN')
ORDER BY JOB;
출력결과

     EMPNO ENAME      JOB              SAL            MAX(SAL)OVER(PARTITIONBYJOB)
---------- ---------- --------- ---------- ---------------------------------------
      7782 CLARK      MANAGER         2450                                    2975
      7698 BLAKE      MANAGER         2850                                    2975
      7566 JONES      MANAGER         2975                                    2975
      7844 TURNER     SALESMAN        1500                                    1600
      7521 WARD       SALESMAN        1250                                    1600
      7499 ALLEN      SALESMAN        1600                                    1600
      7654 MARTIN     SALESMAN        1250                                    1600
이렇게 PARTITION BY를 사용하면 직업별 봉급 최댓값을 각 직업 행에 출력해준다.

예시02 - ROW_NUMBER
-- 사원번호, 사원명, 직업, 봉급을 출력하되,
-- 직업별 봉급이 낮은 순서대로 순위를 확인할 수 있도록 조회해보자.

SELECT EMPNO, ENAME, JOB, SAL,
ROW_NUMBER() OVER(PARTITION BY JOB ORDER BY SAL) "행번호"
FROM C##SCOTT.EMP
WHERE JOB IN ('MANAGER', 'SALESMAN')
ORDER BY JOB;
출력결과

     EMPNO ENAME      JOB              SAL        행번호
---------- ---------- --------- ---------- ----------
      7782 CLARK      MANAGER         2450          1
      7698 BLAKE      MANAGER         2850          2
      7566 JONES      MANAGER         2975          3
      7521 WARD       SALESMAN        1250          1
      7654 MARTIN     SALESMAN        1250          2
      7844 TURNER     SALESMAN        1500          3
      7499 ALLEN      SALESMAN        1600          4
SQL문 두번째 줄에서, PRATITION BY JOB ORDER BY SAL 로 인해서
각 직업별 봉급이 낮은 순서대로 행번호를 붙인다.

예시03 - RANK
-- 사원번호, 사원의 이름, 부서번호, 봉급, 부서별로 급여가 많은 사원부터 순위를 출력하자.

SELECT EMPNO, ENAME, DEPTNO, SAL,
RANK() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) "순  위"
FROM C##SCOTT.EMP;
출력결과

     EMPNO ENAME          DEPTNO        SAL       순  위
---------- ---------- ---------- ---------- ----------
      7839 KING               10       5000          1
      7782 CLARK              10       2450          2
      7934 MILLER             10       1300          3
      7788 SCOTT              20       3000          1 -- 부서번호 20 내에서 봉급이 같음
      7902 FORD               20       3000          1 -- 부서번호 20 내에서 봉급이 같음
      7566 JONES              20       2975          3 -- 다음 순위는 1등이 2명이므로, 3등으로 책정됨
      7876 ADAMS              20       1100          4
      7369 SMITH              20        800          5
      7698 BLAKE              30       2850          1
      7499 ALLEN              30       1600          2
      7844 TURNER             30       1500          3
      7654 MARTIN             30       1250          4
      7521 WARD               30       1250          4
      7900 JAMES              30        950          6
DESC 옵션을 주어, 파티션 내에서 봉급을 내림차순으로 정렬했다.
RANK의 경우 동일 봉급일 때, 같은 순위를 부여하고, 그 다음 순위는 순위 + N 의 순위가 부여된다.
즉, 부서번호 10인 사원들 중, 봉급이 7000으로 동일한 5명이 있다면 다섯명은 모두 동일 순위(EX. 3)를 부여받고
다음 순위는 3 + 5인 8번이 된다.

또 다른 순위 분석함수인 DENSE_RANK와 비교해보자.
예시04 - DENSE_RANK
-- 사원번호, 사원의 이름, 부서번호, 봉급, 부서별로 급여가 많은 사원부터 순위를 출력하자.

SELECT EMPNO, ENAME, DEPTNO, SAL,
DENSE_RANK() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) "순  위"
FROM C##SCOTT.EMP;
출력결과

     EMPNO ENAME          DEPTNO        SAL       순  위
---------- ---------- ---------- ---------- ----------
      7839 KING               10       5000          1
      7782 CLARK              10       2450          2
      7934 MILLER             10       1300          3
      7788 SCOTT              20       3000          1 -- 부서번호 20 내에서 봉급이 같음
      7902 FORD               20       3000          1 -- 부서번호 20 내에서 봉급이 같음
      7566 JONES              20       2975          2 -- 다음 순위는 무조건 한단계 다음 순위인 2번으로 책정됨
      7876 ADAMS              20       1100          3
      7369 SMITH              20        800          4
      7698 BLAKE              30       2850          1
      7499 ALLEN              30       1600          2
      7844 TURNER             30       1500          3
      7654 MARTIN             30       1250          4
      7521 WARD               30       1250          4
      7900 JAMES              30        950          5
예시03과 같이, DESC옵션을 주어 파티션 내에서 봉급을 내림차순으로 정렬했다.
DENSE-RANK의 경우 동일 봉급일 때, 동일 순위를 부여하고 그 다음 순위는 순위 + 1 의 순위가 부여된다.
즉, 부서번호 10인 사원들 중, 봉급이 7000으로 동일한 5명이 있다면 다섯명은 모두 동일 순위(EX. 3)를 부여받고
다음 순위는 3 + 1인 4번이 된다.



자바스크립트 호이스팅 Hoisting
 

호이스팅이란 변수나 함수가 어디서 선언이 되든지간에 

최상단에 위치하게 되어 동일 스코프 에서는 어디서든 참조 할수 있다는 것을 말한다.

코드로 설명 하면 아주 간단하니 바로 밑에 예제 보자

 

 

addString("가나다", "라마바사");


function addString(str1, str2)
{
    return str1 + str2;
}
 

결과 : 가나다라마바사

 


선언 된적이 없는 것을 참조하려고 할때

addString을 실행 시점에  function addString이 선언되어있지 않으므로 

에러가 나는 상황이지만 정상 동작 한다.  addString 함수를 상단으로 올려서 참조 할수 있도록 해줬다. 

이를 호이스팅 이라고 한다.

위에서 함수 선언은 동시에 초기화가 이루어 지기 때문에 참조 뿐만 아니라 실행도 가능하다.


아래와 같은 함수표현식 스타일은 어떨까?

 

addString("123123", "456456");

var addString = function (str1, str2)
{
     return str1 + str2;
}
 

addString을 함수표현식 스타일로 선언해도 호이스팅 되며, 실행이 될까??

 

내가 구매한 책에서는 불가능 하다고 되어 있었다.

( 역시 IE11 으로 테스트시 에러가 발생한다. )

 


 

 

크롬에서도 실행시에 결과값을 undefined로 예상 했었다.

 

하지만.. Chrome 버전 95.0.4638.54(공식 빌드)에서는 정상적으로 동작한다. 

 


 

이건.. 브라우저와 javascript 엔진 버전상의 처리 방식이 다르므로, 사용시 유의 해야겠다.

 

 

 

실행이 안되는 케이스는 어떤것이 있을까??

 

함수 표현식으로 사용하되 var를 쓰지 않고 let, const를 사용하면 실행이 안된다.

 

addString("123123", "456456");

let addString = function (str1, str2)
{
     return str1 + str2;
}
 

addString("123123", "456456");

const addString = function (str1, str2)
{
     return str1 + str2;
}
