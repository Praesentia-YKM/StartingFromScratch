[Spring] Servlet이란?
1. Servlet
Spring 공부를 하기위해서는 서블릿의 이해가 필수적이다.

http 통신 기반의 클래스(대부분의 컨트롤러가 이에 해당된다.)를 살펴보면 어노테이션 기반으로든, 매개변수로든 서블릿 클래스가 활용된다는 것을 알 수 있다. 

그렇다면 서블릿은 무엇인가?

서블릿은 웹 프로그래밍에서 클라이언트 요청을 처리하고

처리 결과를 클라이언트에 전송하는 기술.

자바로 구현된 CGI(Common gateway Interface) 



CGI란 별도로 제작된 웹 서버와 프로그램간의 교환 방식으로, 어떠한 프로그래밍 언어로도 구현이 가능하며, 별도로 만들어놓은 프로그램에 HTML의 GET POST방법으로 클라이언트의 데이터를 환경변수로 전달하고 프로그램의 표준 출력 결과를 클라이언트에 전송하는것을 말합니다



쉽게 말하자면 자바를 사용해서 웹을 만들기 위해 필요한 기술이다.



서블릿의 특징은 다음과 같다.

클라이언트의 요청에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트

html을 사용해서 요청에 응답한다

Java thread를 통해 동작한다

MVC패턴중 Controller로 이용된다

HTTP 프로토콜 서비스를 지원하는 javax.servlet.http.HttpServlet 클래스를 상속받는다.(UDP보다 속도가 느림)

HTML 변경시 Servlet을 재 컴파일 해야한다



일반적으로 웹서버는 정적인 페이지만 제공하는데, 동적인 페이지를 제공하기 위해  서블릿을 활용한다. 동적인 페이지란 사용자의 요청에 의해 변화되는 무언가를 제공하는 것을 말하는데, 서블릿이 바로 이러한 동적인 페이지를 제공하기 위해 도움을 주는 어플리케이션이다.



서블릿의 동작은 다음과 같이 이루어진다

사용자가 URL을 클릭하면 HTTP Request를 서블릿 컨테이너로 전송한다

HTTP Request를 전달받은 서블릿 컨테이너는 HttpServletRequest, HttpServletResponse 두 객체를 생성한다.

web.xml은 사용자가 요청한 URL을 분석하여 어느 서블릿에 대해 요청을 한 것인지 찾는다

해당 서블릿에서 service 메소드를 호출한 후 클라이언트의 요청종류 (GET, POST)에 따라 doGet 혹은 doPost를 호출한다.

doGet, doPost 메소드는 동적 페이지를 생성한 후 HttpServletResponse 객체에 응답을 보낸다.

응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킨다


2. Servlet Container
서블릿 컨테이너는 서블릿을 관리해주는 컨테이너를 말한다. 대표적으로 톰캣(Tomcat)이 있다.

서블릿 컨테이너는 클라이언트의 요청을 받아주고 응답할수있도록 웹서버와 소켓을 만들어 통신한다.



서블릿 컨테이너의 역할은 다음과 같다

웹 서버와의 통신 지원 : 서블릿 컨테이너는 서블릿과 웹 서버가 쉽게 통신할수 있게 해준다. 소켓기능들을 API로 제공하여 복잡한 과정을 생략하고, 개발자는 구현해야 할 비즈니스 로직에 대해서만 초점을 맞추면 된다.

서블릿 생명주기 관리 : 서블릿 컨테이너는 서블릿의 탄생과 죽음을 관리한다. 서블릿 클래스를 로딩하여 인스턴스화하고, 초기화 메소드를 호출하고, 요청이 들어오면 적절한 서블릿 메소드를 호출한다.

멀티쓰레드 지원 및 관리 : 서블릿 컨테이너는 요청이 올 때 마다 새로운 자바 쓰레드를 하나 생성하는데, HTTP 서비스 메소드를 실행한 후 쓰레드는 자동으로 죽는다. 이러한 관리를 컨테이너가 알아서 해준다.

선언적인 보안 관리 : 보안관리는 XML 배포 서술자에 기록하므로 보안적 문제로 인해 자바 소스를 수정할 일이 없다.


*서블릿 생명주기란?

클라이언트 요청이 들어오면 컨테이너는 해당 서블릿이 메모리에 존재하는지 확인하고, 없을 경우 init() 메소드를 호출해 적재한다. init()은 최초 한번만 실행되기 때문에 서블릿의 쓰레드에서 공통적으로 사용해야 하는 것이 있다면 오버라이딩하여 구현한다.

init() 이 호출된 후 클라이언트의 요청에 따라서 service 메소드를 통해 대한 응답이 doGet, doPost로 분기된다. 이 때 서블릿 컨테이너가 클라이언트의 요청이 오면 가장 먼저 처리하는 과정으로 생성된 HttpServletRequest, HttpServletResponse에 의해 request와 response객체가 제공된다.

컨테이너가 서블릿에 종료 요청을 하면 destroy() 메소드가 호출되는데 한번만 실행되며, 종료시에 처리해야하는 작업들은 destroy() 메소드를 오버라이딩하여 구혀하면된다.


3. JSP(Java Server Page)
서블릿이 자바 소스코드 속에 HTML이 들어가는 형태라면 JSP는 JAVA 코드가 들어있는 HTML 코드이다. 

이렇게 작성된 HTML코드는 브라우저로 전송되는것이 아닌, 웹 서버내에서 실행되는 부분이다. 

이는 프로그래머의 개발 효율성을 위해 등장한것으로, 실질적으로 서블릿 컨테이너에 의해(WAS) 서블릿으로 변환되어 사용된다.

JSP 동작 방식은 다음과 같다

웹 서버가 사용자의 요청을 받으면 서블릿 컨테이너에 그 요청을 넘긴다.

서블릿 컨테이너는 이를 Servlet객체로 변환하고 기존 서블릿 처리를 진행하듯이 동작 결과를 웹 브라우저로 응답하는 일련의 과정을 거친다.

핸들러 매핑(Handler Mapping)은 HTTP 요청정보를 이용하여 이를 처리할 핸들러 오브젝트, 즉 컨트롤러를 찾아주는 기능을 가진 DispatcherServlet의 전략이다.

스프링은 기본적으로 다섯 가지 핸들러 매핑을 제공한다.

BeanNameUrlHandlerMapping: HTTP 요청 URL과 빈의 이름을 비교하여 일치하는 빈을 찾는다.
ControllerBeanNameHandlerMapping: BeanNameUrlHandlerMapping과 유사하지만 위처럼 빈 이름을 URL 형태로 짓지 않아도 된다는 차이가 있다.
ControllerClassNameHandlerMapping: 빈의 클래스 이름을 URL에 매핑해주는 매핑 클래스이다.
SimpleUrlHandlerMapping: URL과 컨트롤러 매핑정보를 한곳에 모아놓을 수 있는 전략이다.
RequestMappingHandlerMapping: @RequestMapping이라는 애노테이션을 이용해 매핑하는 전략이다.
DispatcherServlet은 init되는 순간 HandlerMapping 전략들을 등록한다. 스프링 부트의 경우 RequestMappingHandlerMapping 전략이 가장 높은 우선 순위를 가진다.

DispatcherServlet은 getHandler 함수를 호출하여 등록된 HandlerMapping전략들의 우선순위 순으로 핸들러를 찾는다.

핸들러 어댑터(Handler Adapter)
핸들러 어댑터(Handler Adapter)는 핸들러 매핑을 통해 검색된 핸들러 객체를 가지고 이에 맞는 어댑터를 찾는 과정이다. 여기서 어댑터란, 2개 이상의 인터페이스에 스펙이 맞지 않을 때, 중간에 이 스펙이 맞도록 변환해주는 역할을 하는 객체이다.

실행 흐름
실행 흐름은 Handler Mapping을 통해 Handler를 조회하고 이를 실행 시킬 Handler Adapter를 조회한다. 이후 조회 된 Handler Adapter를 통해 Handler를 실행한다.

Handler Mapping으로 Handler 조회
Handler Adapter 조회
Handler Adapter 실행

## 추상클래스 (IS - A)

```
abstract class 클래스이름 {
	pulic abstract void 메서드이름();
}
```

미완성 설계도, 미완성 메서드(추상 메서드)를 갖고 있는 클래스필드, 생성자, 추상메서드로 구성

- 클래스 또는 메소드 앞에 abstract를 붙여 추상클래스, 추상메서드를 만든다.
- abstract class는 인스턴스를 생성할 수 없다. 그래서 반드시 서브 클래스가 있어야 한다.
- abstract class를 상속는 하위 클래스는 부모클래스의 abstract 메소드를 반드시 구현해야 한다. (오버라이딩)단, 추상 클래스를 상속받은 자식 클래스도 추상 클래스라면 abstract 메소드를 오버라이딩 하지 않고 또는 일부만 오버라이딩하고 하위 클래스에게 오버라이딩을 위임 할 수 있다.
- 추상클래스 내에서 추상메서드를 호출할 수 있다. 호출할 때는 선언부만 필요하기 때문이다.
- abstract 메소드가 하나 이상 존재하면 abstract class로 명시해야 하지만, abstract 클래스가 반드시 abstract 메소드를 가질 필요는 없다.
- 대체로 abstract은 메소드와 연관이 크고 멤버 변수와는 상관이 없다.
- final과는 반대의 개념으로 두가지를 동시에 사용할 수 없다. final은 아래 참고

---

## 인터페이스(HAS - A)

```
interface class 인터페이스이름 {
	public static final 상수이름 = 값;
	pulic abstract void 메서드이름();
}
```

추상 메서드의 집합구현된 것이 전혀 없는 설계도상수, static 메서드, default 메서드, 추상 메서드로 구성

- public static final 과 public abstract 생략 가능하다. 컴파일 시에 자동으로 생성된다.
- 인터페이스 네이밍 규칙이 있는데 보통 'xxxable' 형식이다.
- 인터페이스는 다중상속을 지원하며, 구현체에 여러개의 인터페이스를 구현 가능하다. (implements a, b, c,,,) 추상메서드가 선언부만 있기 때문에 충돌을 일으키지 않는다.
- 인터페이스의 조상은 인터페이스만 가능하며, 여러개의 인터페이스를 상속(extends) 받을 수 있다.

```
interface A extends B, C { }
interface B {
	void testB();
}
interface C {
	void testC();
}

```

- 인터페이스를 구현하는 클래스가 일부만 구현할 경우 해당 클래스는 abstract를 붙여 추상클래스가 되어야 한다.
- 디폴트 메서드(default method)를 지원하며, 이를 통해 기존 인터페이스 기능을 확장하고, 구현체에 공통적으로 들어갈 기능(코드)를 디폴트 메서드 내부에 작성함으로써 반복되는 코드의 작성을 줄일 수 있다.

> 인터페이스의 장점
> 
- 두 객체 간의 연결, 대화, 소통을 돕는 중간 역학을 한다.
- 유지보수, 변경에 유리한 설계가 가능하다. (유연성)
- 선언과 구현을 분리시킬 수 있게 한다.
- 의존하는 클래스의 변경에 대해 영향을 적게 받는다. (느슨한 결합)
- 개발 시간을 단축할 수 있다. 인터페이스를 이용하면 의존하는 클래스가 다 작성될 때까지 기다리지 않고 개발할 수 있다.
- 표준화가 가능하다. 대표적으로 JDBC가 있다.JDBC: 자바 프로그램에서 다른 기종 간의 데이터베이스를 표준화된 방법으로 접속할 수 있도록 만든 API 규격 => 다양한 데이터베이스가 있고, 이로 인해 애플리케이션에서 데이터베이스에 접속/데이터를 처리하는 방법이 각기 다른 것을 표준화 한 것
- 서로 관계없는 클래스들 간에 관계를 맺어줄 수 있다. 상속 계층도에서 공통점을 찾기 어려울 때는 특정 클래스들을 선별해서 내용이 없는 인터페이스를 구현하게 하면 된다. 예를 들어 매개변수 타입으로 인터페이스를 사용하면 해당 인터페이스를 구현한 클래스만 올 수 있다. (다형성)

---

## 공통점

1. 추상 메서드를 가지고 있다. (미완성 설계도)
2. 상속을 이용하여 구현 가능하다.
3. **자식 클래스에서 추상 메서드를 완성하도록 유도한다.**

## 차이점

1. 추상클래스는 인스턴스 변수 및 메서드, 생성자를 가질 수 있지만, 인터페이스는 추상메서드만 가질 수 있다.
2. 모두 추상메서드를 사용할 수 있지만, 사용용도가 다르다.

보통 클래스의 구분은 추상클래스 상속을 통해 해결하며, 할 수 있는 기능들은 다중 상속이 가능한 인터페이스로 구현한다.

---

## 인터페이스를 이용한 다형성

- 인터페이스도 구현클래스의 부모 클래스가 된다.
- 인터페이스 타입 매개변수는 인터페이스를 구현한 클래스의 객체만 가능하다.
- 인터페이스를 메서드의 리턴타입으로 지정할 수 있다.

---

## 추상클래스, 인터페이스의 적절한 사용 케이스

### 추상메서드

- 자식클래스마다 다르게 구현될 것으로 예상되는 경우

### 추상클래스

- 관련성이 높은 클래스 간에 코드를 공유하고 싶은 경우
- 추상클래스를 상속받은 클래스들이 공통으로 가지는 메소드와 필드가 많거나, public 이외의 접근제어자 사용이 필요한 경우
- non-static, non-final 필드 선언이 필요한 경우. 즉, 각 인스턴스에서 state 변경을 위한 메소드를 선언할 수 있다.

### 인터페이스

- 서로 관련성이 없는 클래스들이 인터페이스를 구현하게 되는 경우에 사용한다. 예를 들어, Comparable, Cloneable 인터페이스는 여러 클래스들에서 구현되는데, 구현클래스들 간에 관련성이 없는 경우가 대부분이다.
- 특정 데이터 타입의 행동을 명시하고 싶은데, 어디서 그 행동이 구현되는지는 신경쓰지 않는 경우.
- 다중상속을 허용하고 싶은 경우

---

## final

> final은 해당 entity가 오로지 한 번 할당될 수 있음을 의미
> 

구체적으로 나눈다면

- final 변수> 해당 변수가 생성자나 대입연산자를 통해 한 번만 초기화 가능
- final 클래스> 상속 불가능왜? 잘못 사용하면 절대 안 되는 경우를 막기 위함예를 들면, String Class는 public final class String으로 정의 되어있으며, String으로 파생되는 클래스는 절대 만들 수 없다.private 메소드도 동일하게 동작한다.
- final 메소드> 오버라이딩(재정의) 불가능왜? 고쳐서 사용하면 절대 안되는 경우를 막기 위함

### final 멤버 변수에 static을 함께 사용하는 이유는?

> static은 해당 데이터의 메모리 할당을 컴파일 시간에 할 것임을 의미
> 

클래스에서 사용할 해당 멤버 변수의 데이터와 그 의미, 용도를 고정시키기 위함모든 인스턴스에서 고정된 값을 동일하게 사용한다면 인스턴스가 생성될 때 마다 새로 메모리를 잡아서 초기화 시키지 않고**클래스 레벨에서 한 번만 잡아서 하나의 메모리 공간을 사용하면 되기 때문**
